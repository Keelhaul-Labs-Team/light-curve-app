// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'publish_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$PublishStateTearOff {
  const _$PublishStateTearOff();

  _PublishState call(
      {String? pathVideo,
      String? pathThumbnail,
      String? chart1,
      String? chart2,
      required bool isSubmitting,
      required PublishStep publishStep,
      required Option<Either<PublishFailure, Unit>>
          publishFailureOrSuccessOption}) {
    return _PublishState(
      pathVideo: pathVideo,
      pathThumbnail: pathThumbnail,
      chart1: chart1,
      chart2: chart2,
      isSubmitting: isSubmitting,
      publishStep: publishStep,
      publishFailureOrSuccessOption: publishFailureOrSuccessOption,
    );
  }
}

/// @nodoc
const $PublishState = _$PublishStateTearOff();

/// @nodoc
mixin _$PublishState {
  String? get pathVideo => throw _privateConstructorUsedError;
  String? get pathThumbnail => throw _privateConstructorUsedError;
  String? get chart1 => throw _privateConstructorUsedError;
  String? get chart2 => throw _privateConstructorUsedError;
  bool get isSubmitting => throw _privateConstructorUsedError;
  PublishStep get publishStep => throw _privateConstructorUsedError;
  Option<Either<PublishFailure, Unit>> get publishFailureOrSuccessOption =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $PublishStateCopyWith<PublishState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PublishStateCopyWith<$Res> {
  factory $PublishStateCopyWith(
          PublishState value, $Res Function(PublishState) then) =
      _$PublishStateCopyWithImpl<$Res>;
  $Res call(
      {String? pathVideo,
      String? pathThumbnail,
      String? chart1,
      String? chart2,
      bool isSubmitting,
      PublishStep publishStep,
      Option<Either<PublishFailure, Unit>> publishFailureOrSuccessOption});

  $PublishStepCopyWith<$Res> get publishStep;
}

/// @nodoc
class _$PublishStateCopyWithImpl<$Res> implements $PublishStateCopyWith<$Res> {
  _$PublishStateCopyWithImpl(this._value, this._then);

  final PublishState _value;
  // ignore: unused_field
  final $Res Function(PublishState) _then;

  @override
  $Res call({
    Object? pathVideo = freezed,
    Object? pathThumbnail = freezed,
    Object? chart1 = freezed,
    Object? chart2 = freezed,
    Object? isSubmitting = freezed,
    Object? publishStep = freezed,
    Object? publishFailureOrSuccessOption = freezed,
  }) {
    return _then(_value.copyWith(
      pathVideo: pathVideo == freezed
          ? _value.pathVideo
          : pathVideo // ignore: cast_nullable_to_non_nullable
              as String?,
      pathThumbnail: pathThumbnail == freezed
          ? _value.pathThumbnail
          : pathThumbnail // ignore: cast_nullable_to_non_nullable
              as String?,
      chart1: chart1 == freezed
          ? _value.chart1
          : chart1 // ignore: cast_nullable_to_non_nullable
              as String?,
      chart2: chart2 == freezed
          ? _value.chart2
          : chart2 // ignore: cast_nullable_to_non_nullable
              as String?,
      isSubmitting: isSubmitting == freezed
          ? _value.isSubmitting
          : isSubmitting // ignore: cast_nullable_to_non_nullable
              as bool,
      publishStep: publishStep == freezed
          ? _value.publishStep
          : publishStep // ignore: cast_nullable_to_non_nullable
              as PublishStep,
      publishFailureOrSuccessOption: publishFailureOrSuccessOption == freezed
          ? _value.publishFailureOrSuccessOption
          : publishFailureOrSuccessOption // ignore: cast_nullable_to_non_nullable
              as Option<Either<PublishFailure, Unit>>,
    ));
  }

  @override
  $PublishStepCopyWith<$Res> get publishStep {
    return $PublishStepCopyWith<$Res>(_value.publishStep, (value) {
      return _then(_value.copyWith(publishStep: value));
    });
  }
}

/// @nodoc
abstract class _$PublishStateCopyWith<$Res>
    implements $PublishStateCopyWith<$Res> {
  factory _$PublishStateCopyWith(
          _PublishState value, $Res Function(_PublishState) then) =
      __$PublishStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {String? pathVideo,
      String? pathThumbnail,
      String? chart1,
      String? chart2,
      bool isSubmitting,
      PublishStep publishStep,
      Option<Either<PublishFailure, Unit>> publishFailureOrSuccessOption});

  @override
  $PublishStepCopyWith<$Res> get publishStep;
}

/// @nodoc
class __$PublishStateCopyWithImpl<$Res> extends _$PublishStateCopyWithImpl<$Res>
    implements _$PublishStateCopyWith<$Res> {
  __$PublishStateCopyWithImpl(
      _PublishState _value, $Res Function(_PublishState) _then)
      : super(_value, (v) => _then(v as _PublishState));

  @override
  _PublishState get _value => super._value as _PublishState;

  @override
  $Res call({
    Object? pathVideo = freezed,
    Object? pathThumbnail = freezed,
    Object? chart1 = freezed,
    Object? chart2 = freezed,
    Object? isSubmitting = freezed,
    Object? publishStep = freezed,
    Object? publishFailureOrSuccessOption = freezed,
  }) {
    return _then(_PublishState(
      pathVideo: pathVideo == freezed
          ? _value.pathVideo
          : pathVideo // ignore: cast_nullable_to_non_nullable
              as String?,
      pathThumbnail: pathThumbnail == freezed
          ? _value.pathThumbnail
          : pathThumbnail // ignore: cast_nullable_to_non_nullable
              as String?,
      chart1: chart1 == freezed
          ? _value.chart1
          : chart1 // ignore: cast_nullable_to_non_nullable
              as String?,
      chart2: chart2 == freezed
          ? _value.chart2
          : chart2 // ignore: cast_nullable_to_non_nullable
              as String?,
      isSubmitting: isSubmitting == freezed
          ? _value.isSubmitting
          : isSubmitting // ignore: cast_nullable_to_non_nullable
              as bool,
      publishStep: publishStep == freezed
          ? _value.publishStep
          : publishStep // ignore: cast_nullable_to_non_nullable
              as PublishStep,
      publishFailureOrSuccessOption: publishFailureOrSuccessOption == freezed
          ? _value.publishFailureOrSuccessOption
          : publishFailureOrSuccessOption // ignore: cast_nullable_to_non_nullable
              as Option<Either<PublishFailure, Unit>>,
    ));
  }
}

/// @nodoc

class _$_PublishState implements _PublishState {
  _$_PublishState(
      {this.pathVideo,
      this.pathThumbnail,
      this.chart1,
      this.chart2,
      required this.isSubmitting,
      required this.publishStep,
      required this.publishFailureOrSuccessOption});

  @override
  final String? pathVideo;
  @override
  final String? pathThumbnail;
  @override
  final String? chart1;
  @override
  final String? chart2;
  @override
  final bool isSubmitting;
  @override
  final PublishStep publishStep;
  @override
  final Option<Either<PublishFailure, Unit>> publishFailureOrSuccessOption;

  @override
  String toString() {
    return 'PublishState(pathVideo: $pathVideo, pathThumbnail: $pathThumbnail, chart1: $chart1, chart2: $chart2, isSubmitting: $isSubmitting, publishStep: $publishStep, publishFailureOrSuccessOption: $publishFailureOrSuccessOption)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _PublishState &&
            (identical(other.pathVideo, pathVideo) ||
                const DeepCollectionEquality()
                    .equals(other.pathVideo, pathVideo)) &&
            (identical(other.pathThumbnail, pathThumbnail) ||
                const DeepCollectionEquality()
                    .equals(other.pathThumbnail, pathThumbnail)) &&
            (identical(other.chart1, chart1) ||
                const DeepCollectionEquality().equals(other.chart1, chart1)) &&
            (identical(other.chart2, chart2) ||
                const DeepCollectionEquality().equals(other.chart2, chart2)) &&
            (identical(other.isSubmitting, isSubmitting) ||
                const DeepCollectionEquality()
                    .equals(other.isSubmitting, isSubmitting)) &&
            (identical(other.publishStep, publishStep) ||
                const DeepCollectionEquality()
                    .equals(other.publishStep, publishStep)) &&
            (identical(other.publishFailureOrSuccessOption,
                    publishFailureOrSuccessOption) ||
                const DeepCollectionEquality().equals(
                    other.publishFailureOrSuccessOption,
                    publishFailureOrSuccessOption)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(pathVideo) ^
      const DeepCollectionEquality().hash(pathThumbnail) ^
      const DeepCollectionEquality().hash(chart1) ^
      const DeepCollectionEquality().hash(chart2) ^
      const DeepCollectionEquality().hash(isSubmitting) ^
      const DeepCollectionEquality().hash(publishStep) ^
      const DeepCollectionEquality().hash(publishFailureOrSuccessOption);

  @JsonKey(ignore: true)
  @override
  _$PublishStateCopyWith<_PublishState> get copyWith =>
      __$PublishStateCopyWithImpl<_PublishState>(this, _$identity);
}

abstract class _PublishState implements PublishState {
  factory _PublishState(
      {String? pathVideo,
      String? pathThumbnail,
      String? chart1,
      String? chart2,
      required bool isSubmitting,
      required PublishStep publishStep,
      required Option<Either<PublishFailure, Unit>>
          publishFailureOrSuccessOption}) = _$_PublishState;

  @override
  String? get pathVideo => throw _privateConstructorUsedError;
  @override
  String? get pathThumbnail => throw _privateConstructorUsedError;
  @override
  String? get chart1 => throw _privateConstructorUsedError;
  @override
  String? get chart2 => throw _privateConstructorUsedError;
  @override
  bool get isSubmitting => throw _privateConstructorUsedError;
  @override
  PublishStep get publishStep => throw _privateConstructorUsedError;
  @override
  Option<Either<PublishFailure, Unit>> get publishFailureOrSuccessOption =>
      throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$PublishStateCopyWith<_PublishState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$PublishStepTearOff {
  const _$PublishStepTearOff();

  InitStep init() {
    return const InitStep();
  }

  LoadedStep loaded() {
    return const LoadedStep();
  }

  CalculateStep calculated() {
    return const CalculateStep();
  }
}

/// @nodoc
const $PublishStep = _$PublishStepTearOff();

/// @nodoc
mixin _$PublishStep {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loaded,
    required TResult Function() calculated,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loaded,
    TResult Function()? calculated,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitStep value) init,
    required TResult Function(LoadedStep value) loaded,
    required TResult Function(CalculateStep value) calculated,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitStep value)? init,
    TResult Function(LoadedStep value)? loaded,
    TResult Function(CalculateStep value)? calculated,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PublishStepCopyWith<$Res> {
  factory $PublishStepCopyWith(
          PublishStep value, $Res Function(PublishStep) then) =
      _$PublishStepCopyWithImpl<$Res>;
}

/// @nodoc
class _$PublishStepCopyWithImpl<$Res> implements $PublishStepCopyWith<$Res> {
  _$PublishStepCopyWithImpl(this._value, this._then);

  final PublishStep _value;
  // ignore: unused_field
  final $Res Function(PublishStep) _then;
}

/// @nodoc
abstract class $InitStepCopyWith<$Res> {
  factory $InitStepCopyWith(InitStep value, $Res Function(InitStep) then) =
      _$InitStepCopyWithImpl<$Res>;
}

/// @nodoc
class _$InitStepCopyWithImpl<$Res> extends _$PublishStepCopyWithImpl<$Res>
    implements $InitStepCopyWith<$Res> {
  _$InitStepCopyWithImpl(InitStep _value, $Res Function(InitStep) _then)
      : super(_value, (v) => _then(v as InitStep));

  @override
  InitStep get _value => super._value as InitStep;
}

/// @nodoc

class _$InitStep implements InitStep {
  const _$InitStep();

  @override
  String toString() {
    return 'PublishStep.init()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is InitStep);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loaded,
    required TResult Function() calculated,
  }) {
    return init();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loaded,
    TResult Function()? calculated,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitStep value) init,
    required TResult Function(LoadedStep value) loaded,
    required TResult Function(CalculateStep value) calculated,
  }) {
    return init(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitStep value)? init,
    TResult Function(LoadedStep value)? loaded,
    TResult Function(CalculateStep value)? calculated,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init(this);
    }
    return orElse();
  }
}

abstract class InitStep implements PublishStep {
  const factory InitStep() = _$InitStep;
}

/// @nodoc
abstract class $LoadedStepCopyWith<$Res> {
  factory $LoadedStepCopyWith(
          LoadedStep value, $Res Function(LoadedStep) then) =
      _$LoadedStepCopyWithImpl<$Res>;
}

/// @nodoc
class _$LoadedStepCopyWithImpl<$Res> extends _$PublishStepCopyWithImpl<$Res>
    implements $LoadedStepCopyWith<$Res> {
  _$LoadedStepCopyWithImpl(LoadedStep _value, $Res Function(LoadedStep) _then)
      : super(_value, (v) => _then(v as LoadedStep));

  @override
  LoadedStep get _value => super._value as LoadedStep;
}

/// @nodoc

class _$LoadedStep implements LoadedStep {
  const _$LoadedStep();

  @override
  String toString() {
    return 'PublishStep.loaded()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is LoadedStep);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loaded,
    required TResult Function() calculated,
  }) {
    return loaded();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loaded,
    TResult Function()? calculated,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitStep value) init,
    required TResult Function(LoadedStep value) loaded,
    required TResult Function(CalculateStep value) calculated,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitStep value)? init,
    TResult Function(LoadedStep value)? loaded,
    TResult Function(CalculateStep value)? calculated,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class LoadedStep implements PublishStep {
  const factory LoadedStep() = _$LoadedStep;
}

/// @nodoc
abstract class $CalculateStepCopyWith<$Res> {
  factory $CalculateStepCopyWith(
          CalculateStep value, $Res Function(CalculateStep) then) =
      _$CalculateStepCopyWithImpl<$Res>;
}

/// @nodoc
class _$CalculateStepCopyWithImpl<$Res> extends _$PublishStepCopyWithImpl<$Res>
    implements $CalculateStepCopyWith<$Res> {
  _$CalculateStepCopyWithImpl(
      CalculateStep _value, $Res Function(CalculateStep) _then)
      : super(_value, (v) => _then(v as CalculateStep));

  @override
  CalculateStep get _value => super._value as CalculateStep;
}

/// @nodoc

class _$CalculateStep implements CalculateStep {
  const _$CalculateStep();

  @override
  String toString() {
    return 'PublishStep.calculated()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is CalculateStep);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function() loaded,
    required TResult Function() calculated,
  }) {
    return calculated();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function()? loaded,
    TResult Function()? calculated,
    required TResult orElse(),
  }) {
    if (calculated != null) {
      return calculated();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InitStep value) init,
    required TResult Function(LoadedStep value) loaded,
    required TResult Function(CalculateStep value) calculated,
  }) {
    return calculated(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InitStep value)? init,
    TResult Function(LoadedStep value)? loaded,
    TResult Function(CalculateStep value)? calculated,
    required TResult orElse(),
  }) {
    if (calculated != null) {
      return calculated(this);
    }
    return orElse();
  }
}

abstract class CalculateStep implements PublishStep {
  const factory CalculateStep() = _$CalculateStep;
}
